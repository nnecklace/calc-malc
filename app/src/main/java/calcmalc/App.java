/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package calcmalc;

import calcmalc.structures.ASTNode;
import calcmalc.structures.Stack;
import calcmalc.ui.UI;
import calcmalc.exceptions.EvaluatorException;
import calcmalc.exceptions.LexerException;
import calcmalc.logic.Evaluator;
import calcmalc.logic.Lexer;
import calcmalc.logic.Parser;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.ParseException;
import java.util.Scanner;

/**
 * @author nnecklace
 */
public class App {
    private static Evaluator evaluator = new Evaluator();
    private static Lexer lexer = new Lexer();
    private static Parser parser = new Parser();
    public static Output output = new Output();

    public static class Output {
        public Number numOutput;
        public String variableOutput;
        public String errorOutput;

        public void setErrorOutput(String errorOutput) {
            this.errorOutput = errorOutput;
        }

        public void setVariableOutput(String variableOutput) {
            this.variableOutput = variableOutput;
        }

        public void setNumOutput(Number numOutput) {
            this.numOutput = numOutput;
        }

        public void printOutput() {
            if (errorOutput != null) {
                System.err.println(errorOutput);
            } else {
                if (numOutput != null) {
                    System.out.println(numOutput);
                } else {
                    System.out.println(variableOutput);
                }
            }
        }

        public void clear() {
            this.errorOutput = null;
            this.variableOutput = null;
            this.numOutput = null;
        }
    }

    /**
     * Method renders ascii greeting message
     * @return greeting message
     */
    public static String getGreeting() {
        return "  _____      _        __  __       _      \n" + "/ _____|    | |      |  \\/  |     | |     \n"
                + "| |     __ _| | ___  | \\  / | __ _| | ___  \n" + "| |    / _` | |/ __| | |\\/| |/ _` | |/ __| \n"
                + "| |___| (_| | | (__  | |  | | (_| | | (__  \n" + "\\_____\\___,_|_|\\___| |_|  |_|\\__,_|_|\\___|\n";
    }

    /**
     * Main entry point for the algorithm
     * Accepts either an argument of repl, which starts the repl
     * Or file name, which contains a valid input to evaluate
     * @param args IO params to read, array can be empty
     * @throws IOException if file cannot be read
     */
    public static void main(String[] args) throws IOException {
        if (args.length > 0) {
            if ("repl".equals(args[0].trim())) {
                System.out.println(new App().getGreeting());
                repl();
            } else if ("ui".equals(args[0].trim())) {
                new UI().run();
            } else {
                read(Paths.get(args[0]));
            }
        }
    }

    /**
     * Formats output according to the number passed in. 
     * If number can be represented as an integer output an integer
     * else output as float
     * @param n the number to format
     * @return formated number
     */
    public static Number format(Number n) {
        if (n.doubleValue() % 1 == 0) {
            return n.longValue();
        }

        return n.doubleValue();
    }

    /**
     * Reads an inteprets the file passed to calcmalc
     * @param file path to the file
     * @throws IOException if the file cannot be read
     */
    public static void read(Path file) throws IOException {
        String contents = Files.readString(file);

        interpret(contents);

        App.output.printOutput();
    }

    /**
     * Interprets and evaluates one line at a time and outputs a value once no lines remain
     * @param input the line to interpret
     */
    public static void interpret(String input) {
        App.output.clear();
        try {
            Stack<ASTNode> nodes = parser.parse(
                lexer.lex(input)
            );

            while (!parser.variables().isEmpty()) {
                App.output.setVariableOutput(evaluator.evaluateAssignment(parser.variables().dequeue()));
            }

            while (!nodes.isEmpty()) {
                App.output.setNumOutput(format(evaluator.evaluate(nodes.pop())));
            }

        } catch (LexerException | ParseException | EvaluatorException | ArithmeticException e) {
            App.output.setErrorOutput(e.getMessage());
        } catch (NumberFormatException e) {
            App.output.setErrorOutput("Number was formatted incorrectly: " + e.getMessage());
        } finally {
            parser = new Parser();
        }
    }

    /**
     * Method starts the repl
     * Repl runs as long as user wants it too
     */
    public static void repl() {
        Scanner input = new Scanner(System.in);

        while (input.hasNextLine()) {
            interpret(input.nextLine());
            App.output.printOutput();
        }

        input.close();
    }
}
